# IntStack.h

### Обяснение на кода

Инклуд гардове
```c++
#ifndef SIMPLIFIED_DATA_STRUCTURES_INTSTACK_H
#define SIMPLIFIED_DATA_STRUCTURES_INTSTACK_H
```

Тези две директиви служат за предотвратяване на включването на един .h файл повече от един път в даден проект. 
Преди компилацията на програмата include директивите събират всички файлове със сорс в един "суперфайл". Проблемът със 
суперфайлът е това, че някои инклуднати файлове могат да се повтарят множество пъти. 
Това е нежелателно и почти сигурно води до грешки. В нашия случай, където имаме template класове с техните дефиниции 
в .h файла /това изглежда е задължително за класовете-шаблони/, двойното включване си е сигурна грешка.

Затова - инклуд гардове. Ако даден файл бъде включен два пъти, тези два реда ще гарантират, че второто, третото и пр. 
включване ще бъдат игнорирани при компилацията. 

Директивата на препроцесора ifndef работи като if конструкцията в езика C++. Нейният "блок от код" е затворен отдолу, 
в края на файла, със
```c++
#endif
```

Благодарение на двете define директиви

```c++
#define Pointer std::shared_ptr<IntStackElement>
#define newIntStackElement(X) (std::make_shared<IntStackElement>(X))
```

препроцесорът на C++ просто ще замени текста Pointer навсякъде във 
файла със std::shared_ptr<IntStackElement> **преди** файлът да се подаде на същинския компилатор.
По същия начин newIntStackElement(X), където X е произволен текст ще се замени със std::make_shared<IntStackElement>(X).

Двете директиви ни позволяват да пишем
```c++
Pointer node = newIntStackElement(value);
```
вместо 

```c++
std::shared_ptr<IntStackElement> node = std::make_shared<IntStackElement>(value);
```

Тъй като Pointer във всеки файл на проекта е дефиниран различно (защото сочи към различен тип елемент), 
се налага в края на всеки файл да кажем на препроцесора да спре заместването. В противен случай, когато препроцесорът
срещне следващата #define Pointer директива във обединения "суперфайл", той "ще се стресне" и ще генерира грешка. 

Това е направено в края на файла с: 

```c++
#undef Pointer
#undef newIntStackElement
```

По-нататък: 

```c++
class IntStackElement {
public:
    int data;
    Pointer next;
    explicit IntStackElement(int newData);
};
```

Основен елемент на опашката. Класът има две полета. Полето data съдържа данните, които се съхраняват в елемента (в случая
число от тип int), а next е указател към следващия елемент. В случай, че няма следващ елемент, този указател е nullptr.

